{
  parserClass="com.github.aleksandrsl.intellijluau.parser.LuauParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Luau"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.aleksandrsl.intellijluau.psi"
  psiImplPackage="com.github.aleksandrsl.intellijluau.psi.impl"
  psiImplUtilClass="com.github.aleksandrsl.intellijluau.psi.LuauPsiImplUtilKt"

  elementTypeHolderClass="com.github.aleksandrsl.intellijluau.psi.LuauTypes"
  elementTypeClass="com.github.aleksandrsl.intellijluau.psi.LuauElementType"
  tokenTypeClass="com.github.aleksandrsl.intellijluau.psi.LuauTokenType"

  tokens = [
          space = "regexp:\s+"
          AND = "and"
          BREAK = "break"
          DO = "do"
          ELSE = "else"
          ELSEIF = "elseif"
          END = "end"
          FALSE = "false"
          FOR = "for"
          FUNCTION = "function"
          IF = "if"
          IN = "in"
          LOCAL = "local"
          NIL = "nil"
          NOT = "not"
          OR = "or"
          REPEAT = "repeat"
          RETURN = "return"
          THEN = "then"
          TRUE = "true"
          UNTIL = "until"
          WHILE = "while"
          REGION = "REGION"
          ENDREGION = "ENDREGION"

          SHEBANG = "#!"
          SHEBANG_CONTENT = "SHEBANG_CONTENT"
          ELLIPSIS = "..."
          CONCAT = ".."
          EQ = "=="
          GE = ">="
          LE = "<="
          NE = "~="
          MINUS = "-"
          PLUS = "+"
          MULT = "*"
          MOD = "%"
          DIV = "/"
          ASSIGN = "="
          GT = ">"
          LT = "<"
          LPAREN = "("
          RPAREN = ")"
          LBRACK = "["
          RBRACK = "]"
          LCURLY = "{"
          RCURLY = "}"
          GETN = "#"
          COMMA = ","
          SEMI = ";"
          COLON = ":"
          DOT = "."
          EXP = "^"
          QUESTION = "?"
          DOUBLE_COLON = "::"
          DOUBLE_DIV = "//"

          PLUS_EQ = "+="
          MINUS_EQ = "-="
          MULT_EQ = "*="
          DIV_EQ = "/="
          DOUBLE_DIV_EQ = "//="
          MOD_EQ = "%="
          EXP_EQ = "^="
          CONCAT_EQ = "..="
          ARROW = "->"
          UNION = "|"
          INTERSECTION = "&"

          SHORT_COMMENT="SHORT_COMMENT"
          DOC_BLOCK_COMMENT="DOC_BLOCK_COMMENT"
          DOC_COMMENT="DOC_COMMENT"
          BLOCK_COMMENT="BLOCK_COMMENT"
          ID="regexp:[A-Za-z_][A-Za-z0-9_]*"
          NUMBER="regexp:[0-9]+"
          STRING = "regexp:\"\S*\""
    ]

    implements(".*soft_keyword") = "com.github.aleksandrsl.intellijluau.psi.LuauSoftKeyword"
}


luau_file ::= shebang_line? block
shebang_line ::= SHEBANG SHEBANG_CONTENT

block ::= (statement ';'?)* (last_statement ';'?)?

statement ::=
     type_declaration_statement
     | do_statement
     | while_statement
     | repeat_statement
     | if_statement
     | classic_for_statement
     | foreach_statement
     | def_statement
     | compound_op_statement
     | assignment_statement
     // Maybe not the best fix, but expressionStatement is moved below ifStatement on purpose
     // expressionStatement includes ifExpression but most of the time we want ifStatement to be matched first, e.g. to fix nested conditions
     | expression_statement
     { recoverWhile = statement_recover }

// TODO (AleksandrSl 20/06/2024): Should I add table parenthesis
private statement_recover ::= !(
  ID
  | ',' | ';'
  | 'local' | 'do' | 'while' | 'repeat' | 'function' | 'if' | 'for' | 'return' | break
  | nil | true | false | STRING | NUMBER | export_soft_keyword | type_soft_keyword
  | un_op
)

do_statement ::= 'do' block 'end' { pin = 1 }
while_statement ::= 'while' expression 'do' block 'end' { pin = 1 }
repeat_statement ::= 'repeat' block 'until' expression { pin = 1 }
if_statement ::= 'if' expression 'then' block ('elseif' expression 'then' block)* ('else' block)? 'end' { pin = 1 }
// TODO: Should I have a binding list here?
// TODO (AleksandrSl 20/06/2024): I copied pin = 3, but I guess it is the way
classic_for_statement ::= 'for' binding '=' expression ',' expression (',' expression)? 'do' block 'end' { pin = 3 }
// Rename for into numeric_for and generic_for as in lua docs
foreach_statement ::= 'for' binding_list 'in' exp_list 'do' block 'end' { pin = 1 }
// I guess the problem is here, at least part of it. Because the error is bin_op or , is expected. And bin_op is a part of expression
assignment_statement ::= var_list '=' exp_list { pin = 2 }
compound_op_statement ::= var compound_op expression { pin = 2 }
expression_statement ::= expression { pin = 1 }
private def_statement ::= func_def_statement | local_func_def_statement | local_def_statement // class_method_def_statement
// TODO (AleksandrSl 20/06/2024): Is continue really last statement?
last_statement ::= 'return' exp_list? | 'break' | continue_soft_keyword
// TODO (AleksandrSl 20/06/2024): How does pin work with the optional elements?
type_declaration_statement ::= export_soft_keyword? type_soft_keyword ID ('<' generic_type_list_with_defaults '>')? '=' type { pin = 2 }
export_soft_keyword ::= 'export'
continue_soft_keyword ::= 'continue'
type_soft_keyword ::= 'type'
typeof_soft_keyword ::= 'typeof'

local_def_statement ::= 'local' binding_list ('=' exp_list)? { pin = 1 }
func_def_statement ::= 'function' func_name func_body { pin = 1; methods=[getPresentation] }
//classMethodName ::=  nameExpr (funcPrefixRef)* (('.' ID) | (':' ID))
//class_method_def_statement ::= 'function' classMethodName funcBody

// Without pinning somehow it won't match the function but local_def_statement instead even though it is later in the variants.
// Looks like parser first searches for pins if there are any in the rules.

// Rule also scans until it encounters recoverWhile symbol and then tries something else for unknown reason.
// There no errors what are you recovering from?
// Moreover, it safely parses name of the function (it's also an ID) and then stops inside the generic_type_list, what the actual fuck is this?
// Ok, it actually fails to parse conditions and assignments inside the body, so it actually fails to parse function and starts doing this shit.
// I broke somethings with pinning

// Even if the code is perfectly normal.
// 'function' is pinned because pinning local won't allow to match variable definitions
local_func_def_statement ::= 'local' 'function' func_name func_body { pin = 2 }

func_name ::= ID ('.' ID)* (':' ID)?
func_body ::= ('<' generic_type_list '>')? '(' par_list? ')' (':' return_type)? block 'end'
par_list ::= binding_list (',' type_pack_parameter)? | type_pack_parameter
private type_pack_parameter ::= '...' (':' (generic_type_pack | type))?

exp_list ::= expression // (',' expression)*

// Needed for assignments with local. You shouldn't be able to use `local a.b.c = 10`
binding ::= ID (':' type)?  {
  // No idea why they use mixins or methods instead of extend, probably because they need more than one implementation
  // But usually it's not the case.
  extends="com.github.aleksandrsl.intellijluau.psi.LuauNamedElementImpl";
  implements="com.github.aleksandrsl.intellijluau.psi.LuauNamedElement"
}
binding_list ::= binding (',' binding)* // equivalent of Lua 5.1 'namelist', except with optional type annotations

var_list ::= var (',' var)*
var ::= primary_exp
var_reference ::= ID { methods=[getReferences] }
prefix_exp ::= var_reference | '(' expression ')' | table_constructor
postfix_exp ::= func_args | index_expr

// I guess this is a bit more permissive that it should be? e.g. it allows {}()
primary_exp ::= prefix_exp postfix_exp*

left index_expr ::= '[' expression ']' | '.' ID | ':' ID

func_args ::= list_args | single_arg
// TODO (AleksandrSl 21/06/2024): I wonder when you may have table and string as an arg without the parenthesis
// Well, shit, sugar we deserved
// > A call of the form f{fields} is syntactic sugar for f({fields});
//   that is, the argument list is a single new table.
//   A call of the form f'string' (or f"string" or f[[string]]) is syntactic sugar for f('string');
//   that is, the argument list is a single literal string
// Only STRING is allowed, not template_string
single_arg ::= table_constructor | STRING { extends = func_args }
private arg_expr_list ::= (expression ',')* (expression |& ')') // { pin = 1 }
list_args ::= '(' (arg_expr_list)? ')' { extends = func_args; pin = 1 }


expression ::= simple_exp | as_exp | unary_exp | binary_exp
// See this https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities for extends example. In this case Parser switches to a different algo (Pratt) so it's ok to have left-recursion
unary_exp ::= un_op expression {extends=expression}
binary_exp ::= expression bin_op expression {extends=expression}
ifelse_exp ::= 'if' expression 'then' expression ('elseif' expression 'then' expression)* 'else' expression
// TODO (AleksandrSl 21/06/2024): I guess I may have () around cast and they maybe be even necessary? Can I cast all simple expressions?
as_exp ::= simple_exp '::' type {extends=expression}
template_string ::= TEMPLATE_STRING_SQUOTE (STRING | ('{' expression '}'))* TEMPLATE_STRING_EQUOTE
simple_exp ::=  table_constructor | closure_exp | primary_exp | ifelse_exp | literal_exp | template_string {extends=expression}

private literal_exp ::= NUMBER | STRING | 'nil' | 'true' | 'false' | '...'

closure_exp ::= 'function' func_body

table_constructor ::= '{' field_list? '}'
field_list ::= field (field_sep field)* field_sep?
field ::= '[' expression ']' '=' expression | ID '=' expression | expression
// Why the hell they allow two separators
field_sep ::= ',' | ';'

compound_op ::= '+=' | '-=' | '*=' | '/=' | '%=' | '^=' | '..=' | '//='
bin_op ::= '+' | '-' | '*' | '/' | '//' | '^' | '%' | '..' | '<' | '<=' | '>' | '>=' | '==' | '~=' | 'and' | 'or'
un_op ::= '-' | 'not' | '#'

simple_type ::=
    'nil'
    | singleton_type
    | typeof_soft_keyword '(' expression ')'
    | ID ('.' ID)? ('<' type_params? '>')?
    | table_type
    | function_type
    | '(' type ')'

singleton_type ::= STRING | 'true' | 'false'

// Why ? is used in UnionSuffix only, is it not possible to use with &? I'll move it for now.
union_suffix ::= ('|' simple_type '?'?)+
intersection_suffix ::= ('&' simple_type)+
type ::= simple_type '?'? (union_suffix | intersection_suffix)*

generic_type_pack_parameter ::= ID '...'
generic_type_pack_parameter_with_default ::= ID '...' '=' (type_pack | variadic_type_pack | generic_type_pack)

// Having just ID before the ... fucks everything up, because T... will match just ID and go another step and then later fail, but it won't backtrack and try ...
generic_type_list ::= generic_type_pack_parameter (',' generic_type_pack_parameter)* | ID (',' ID)* (',' generic_type_pack_parameter)*

generic_type_list_with_defaults ::= generic_type_list (',' generic_type_list_with_defaults_item)* | generic_type_list_with_defaults_item (',' generic_type_list_with_defaults_item)*
private generic_type_list_with_defaults_item ::=
    generic_type_pack_parameter_with_default
    | ID '=' type

type_list ::= type (',' type_list)? | '...' type
bound_type_list ::= variadic_type_pack | generic_type_pack | (ID ':')? type (',' bound_type_list)?
type_params ::= (variadic_type_pack | generic_type_pack | type_pack | type) (',' type_params)?
type_pack ::= '(' type_list? ')'
generic_type_pack ::= ID '...'
variadic_type_pack ::= '...' type
return_type ::= type | type_pack
table_indexer ::= '[' type ']' ':' type
table_prop ::= ID ':' type
private table_prop_or_indexer ::= table_prop | table_indexer
prop_list ::= table_prop_or_indexer (field_sep table_prop_or_indexer)* field_sep?
table_type ::= '{' type '}' | '{' prop_list? '}'
function_type ::= ('<' generic_type_list '>')? '(' bound_type_list? ')' '->' return_type
