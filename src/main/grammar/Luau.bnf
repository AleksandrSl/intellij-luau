{
  parserClass="com.github.aleksandrsl.intellijluau.parser.LuauParser"
  parserUtilClass="com.github.aleksandrsl.intellijluau.parser.LuauParserUtilBase"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Luau"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.aleksandrsl.intellijluau.psi"
  psiImplPackage="com.github.aleksandrsl.intellijluau.psi.impl"
  psiImplUtilClass="com.github.aleksandrsl.intellijluau.psi.LuauPsiImplUtilKt"

  elementTypeHolderClass="com.github.aleksandrsl.intellijluau.psi.LuauTypes"
  elementTypeClass="com.github.aleksandrsl.intellijluau.psi.LuauElementType"
  tokenTypeClass="com.github.aleksandrsl.intellijluau.psi.LuauTokenType"

  tokens = [
    space = "regexp:\s+"
    AND = "and"
    BREAK = "break"
    DO = "do"
    ELSE = "else"
    ELSEIF = "elseif"
    END = "end"
    FALSE = "false"
    FOR = "for"
    FUNCTION = "function"
    IF = "if"
    IN = "in"
    LOCAL = "local"
    NIL = "nil"
    NOT = "not"
    OR = "or"
    REPEAT = "repeat"
    RETURN = "return"
    THEN = "then"
    TRUE = "true"
    UNTIL = "until"
    WHILE = "while"
    REGION = "REGION"
    ENDREGION = "ENDREGION"

    SHEBANG = "#!"
    SHEBANG_CONTENT = "SHEBANG_CONTENT"
    ELLIPSIS = "..."
    CONCAT = ".."
    EQ = "=="
    GE = ">="
    LE = "<="
    NE = "~="
    MINUS = "-"
    PLUS = "+"
    MULT = "*"
    MOD = "%"
    DIV = "/"
    ASSIGN = "="
    GT = ">"
    LT = "<"
    AT = "@"
    LPAREN = "("
    RPAREN = ")"
    LBRACK = "["
    RBRACK = "]"
    LCURLY = "{"
    RCURLY = "}"
    GETN = "#"
    COMMA = ","
    SEMI = ";"
    COLON = ":"
    DOT = "."
    EXP = "^"
    QUESTION = "?"
    DOUBLE_COLON = "::"
    DOUBLE_DIV = "//"

    PLUS_EQ = "+="
    MINUS_EQ = "-="
    MULT_EQ = "*="
    DIV_EQ = "/="
    DOUBLE_DIV_EQ = "//="
    MOD_EQ = "%="
    EXP_EQ = "^="
    CONCAT_EQ = "..="
    ARROW = "->"
    UNION = "|"
    INTERSECTION = "&"

    SHORT_COMMENT="SHORT_COMMENT"
    DOC_BLOCK_COMMENT="DOC_BLOCK_COMMENT"
    DOC_COMMENT="DOC_COMMENT"
    BLOCK_COMMENT="BLOCK_COMMENT"
    ID="regexp:[A-Za-z_][A-Za-z0-9_]*"
    NUMBER="regexp:[0-9]+"
    STRING = "regexp:\"\S*\""
  ]

  // TODO (AleksandrSl 08/03/2025): Consider adding the line below, they say it improves performance, but I didn't understand the cons.
  //consumeTokenMethod(".*_expr|expression")="consumeTokenFast"
  extends(".*expr")=expression
  // TODO (AleksandrSl 24/03/2025): Check soft keywords in Haxe token sets, maybe I don't need an interface?
  implements(".*soft_keyword") = "com.github.aleksandrsl.intellijluau.psi.LuauSoftKeyword"
  // I guess element type is not necessary here, but it reduced the amount of types generated
  elementType(".*_op")=operator
  extends(".*_op")=operator
}
// Why do I use postfix and not suffix. It's prevalent in many grammars, not other reasons.

luau_file ::= shebang_line? root_block
shebang_line ::= SHEBANG SHEBANG_CONTENT

// meta rules improve readability, save 200 lines of code, don't add more overhead, at least they generate the same 2 methods that were generated everywhere
private meta list ::= <<p>> (',' <<p>>)*
// element_list ::= '(' element (',' (element | &')'))* ')' {pin(".*")=1} is this example from the docs better?
private meta list_with_trailing_comma ::= <<p>> (',' <<p>>)* ','?
private meta list_with_trailing_sep ::= <<p>> (<<sep>> <<p>>)* <<sep>>?

// TODO (AleksandrSl 10/03/2025): I don't understand do I need a rule here at all or it can be empty
//  Maybe I can just create a token set with all of them
//  I also saw that people do just ::=
fake operator ::= "+"

// It's not mandatory to have the different rules for blocks, but the root one can be simpler
private root_statement_with_recover ::= !('return' | <<eof>>) statement { pin = 1 recoverWhile = statement_recover }
root_block ::= (root_statement_with_recover ';'?)* (return_statement ';'?)?

/* TODO (AleksandrSl 26/03/2025):
 *  I don't know how bad 5 element lookahead is, it's good that they all are just one token.
 *  Consider doing just `statement_with_recover`* and manually checking that last statement is last.
 *  This will simplify the lookahead to !('end' | <<eof>>)
 *  One more fix here, is to have all the tokens that may end the block here. And in my case it's also else and elseif and until.
 *  Probably I can split this into more granular rules if such a long lookahead is a performance problem
 */
private statement_with_recover ::= !('end' | 'return' | continue_soft_keyword | 'break' | 'else' | 'elseif' | 'until' | <<eof>>) statement { pin = 1 recoverWhile = statement_recover }
block ::= (statement_with_recover ';'?)* (last_statement ';'?)?

private statement ::=
    // TODO (AleksandrSl 07/03/2025): There will be a type function support shortly.
     type_declaration_statement
     | do_statement
     | while_statement
     | repeat_statement
     | if_statement
     | classic_for_statement
     | foreach_statement
     | def_statement
     | compound_op_statement
     | assignment_statement
     | expression_statement
{ name = "statement" }

// TODO (AleksandrSl 20/06/2024): I don't know how lua plugin avoid having all the else stuff here,
//  probably because they do manual expressions parsing.
// As far as I see, in the Haxe plugin it's totally fine to have all these here.
private statement_recover ::= !(
  ID
  | ';' | 'end' | 'until' | continue_soft_keyword | 'elseif' | 'else' | '(' | TEMPLATE_STRING_EQUOTE | '}'
  | 'local' | 'do' | 'while' | 'repeat' | 'function' | 'if' | 'for' | 'return' | 'break'
  | export_soft_keyword | type_soft_keyword
  | '@'
)

// TODO (AleksandrSl 26/03/2025): What is the lazy parsing thing?
//  private ShallowBlock ::= <<parseCodeBlockLazy>>
//  I see a lot of it in other plugins.

do_statement ::= 'do' block 'end' { pin = 1 }
while_statement ::= 'while' expression 'do' block 'end' { pin = 1 }
repeat_statement ::= 'repeat' block 'until' expression { pin = 1 }
if_statement ::= 'if' expression 'then' block ('elseif' expression 'then' block)* ('else' block)? 'end' { pin = 1 }
// Yes, we can only have one variable here, and yes we can type it: `for i: number=10,1,-1 do print(i) end`
classic_for_statement ::= 'for' binding '=' expression ',' expression (',' expression)? 'do' block 'end' { pin = 3 }
// Rename for into numeric_for and generic_for as in lua docs
foreach_statement ::= 'for' binding_list 'in' exp_list 'do' block 'end' { pin = 1 }
// TODO: Lol, what error I was talking about
// I guess the problem is here, at least part of it. Because the error is bin_op or , is expected. And bin_op is a part of expression
assignment_statement ::= var_list '=' exp_list { pin = 2 }
compound_op_statement ::= lvalue compound_op expression { pin = 2 }
// Alternative here is to use `external my_external_rule ::= parseMyExternalRule false 10`
expression_statement ::= <<parseExprStatement index_or_call_expr>>
private def_statement ::= local_func_def_statement | method_def_statement | func_def_statement | local_def_statement
private return_statement ::= 'return' exp_list? { pin = 1 }
// Though break and continue can only be inside the cycle, I can't create a separate cycle_block.
// Since many things can be nested inside the cycle. Though functions for example cannot have continue
// even if they are inside the while. I don't think it's worth trying to check this on parser level.
last_statement ::= return_statement | 'break' | continue_soft_keyword
// TODO (AleksandrSl 20/06/2024): How does pin work with the optional elements?
type_declaration_statement ::= export_soft_keyword? type_soft_keyword ID ('<' generic_type_list_with_defaults '>')? '=' type { pin = 2 }
export_soft_keyword ::= 'export'
continue_soft_keyword ::= 'continue'
type_soft_keyword ::= 'type'
typeof_soft_keyword ::= 'typeof'

/* Attributes */
// See https://github.com/luau-lang/rfcs/blob/master/docs/syntax-attribute-functions-deprecated.md for the example of parametrized attributes
// They are a bit in the future, but no one will die if I support the syntax now
literal_table ::= '{' literal_field_list? '}'
private literal_field_list ::= <<list_with_trailing_comma literal_field>>
literal_field ::= (ID '=')? literal

private literal ::= NUMBER | STRING | 'nil' | 'true' | 'false' | literal_table
literal_list ::= <<list literal>>

parameters ::= '(' literal_list? ')' | literal_table | STRING
parametrized_attribute ::= ID parameters?
attribute ::= '@' ID | '@' '[' <<list parametrized_attribute>> ']'
attributes ::= attribute+
/* Attributes End */

local_def_statement ::= 'local' binding_list ('=' exp_list)? { pin = 1 }
func_def_statement ::= attributes? 'function' ID func_body {
  pin = 2
  methods=[getPresentation]
  extends="com.github.aleksandrsl.intellijluau.psi.LuauNamedElementImpl"
  implements="com.github.aleksandrsl.intellijluau.psi.LuauNamedElement"
}

// Without pinning somehow it won't match the function but local_def_statement instead even though it is later in the variants.
// Looks like parser first searches for pins if there are any in the rules.

// Rule also scans until it encounters recoverWhile symbol and then tries something else for unknown reason.
// There no errors what are you recovering from?
// Moreover, it safely parses name of the function (it's also an ID) and then stops inside the generic_type_list, what the actual fuck is this?
// Ok, it actually fails to parse conditions and assignments inside the body, so it actually fails to parse function and starts doing this shit.
// I broke somethings with pinning

// Even if the code is perfectly normal.
// 'function' is pinned because pinning local won't allow to match variable definitions
local_func_def_statement ::= attributes? 'local' 'function' ID func_body {
  pin = 3
  methods=[getPresentation]
  extends="com.github.aleksandrsl.intellijluau.psi.LuauNamedElementImpl"
}
method_def_statement ::= attributes? 'function' method_name func_body { pin = 3; methods=[getPresentation] }

// ('.' ID)* (':' ID | '.' ID) won't work since parser is greedy.
method_name ::= ID (('.' ID)* ':' ID | ('.' ID)+)
type_parameters_list ::= '<' generic_type_list '>'
func_body ::= type_parameters_list? par_list (':' return_type)? block 'end' { pin = 2 }
// binding_list is not used here on purpose to flatter the parameters into one list for better formatting and less PSI
par_list ::= '(' (<<list binding>> (',' type_pack_parameter)? | type_pack_parameter)? ')'
private type_pack_parameter ::= '...' (':' (generic_type_pack | type))?

exp_list ::= <<list expression>>

// Needed for assignments with local. You shouldn't be able to use `local a.b.c = 10`
binding ::= ID (':' type)?  {
  // No idea why they use mixins or methods instead of extend, probably because they need more than one implementation
  // But usually it's not the case.
  extends="com.github.aleksandrsl.intellijluau.psi.LuauNamedElementImpl"
  implements="com.github.aleksandrsl.intellijluau.psi.LuauNamedElement"
  methods=[getPresentation]
}

// equivalent of Lua 5.1 'namelist', except with optional type annotations
binding_list ::= <<list binding>>

var_list ::= <<list lvalue>>
lvalue ::= <<parseIndexAccess index_or_call_expr>> | simple_reference

simple_reference ::= ID { methods=[getReferences] }

// I don't really need this expression, but I can't make it private. Making it inner has no effect.
// TODO (AleksandrSl 25/03/2025): Now I can even inline it, or make it private
value_expr ::= index_or_call_expr | paren_expr | simple_reference

private index_or_call_expr ::= (simple_reference | paren_expr) (index_access | func_call)+
// These are postfixes. not actual access and call, but since they are left and take over the index_or_call_expr above the names suit well
left index_access ::= '[' expression ']' | '.' simple_reference { pin(".*") = 1 }
// I can't pin method call because tables have : as well.
// Nope, I can because it's only in types.
left func_call ::= func_args | ':' simple_reference func_args { pin(".*") = 1 }

func_args ::= list_args | single_arg
// Well, shit, sugar we deserved
// > A call of the form f{fields} is syntactic sugar for f({fields});
//   that is, the argument list is a single new table.
//   A call of the form f'string' (or f"string" or f[[string]]) is syntactic sugar for f('string');
//   that is, the argument list is a single literal string
// Only STRING is allowed, not template_string
single_arg ::= table_constructor | STRING { extends = func_args }
list_args ::= '(' <<list expression>>? ')' { extends = func_args; pin = 1 }

// See this https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities for extends example. In this case Parser switches to a different algo (Pratt) so it's ok to have left-recursion
// TODO (AleksandrSl 07/03/2025): Figure out priorities later
// 2.5.6 â€“ Precedence Take a look at this
expression ::= ifelse_expr
  | or_expr
  | and_expr
  | comparison_expr
  | add_group
  | mul_group
  | unary_group
  | exp_expr
  | primary_group_expr
//  Why do I need this? I just found this in the example
  { extraRoot = true name = "expression" }

// private rules to define operators with the same priority
private unary_group ::= length_expr | not_expr | unary_min_expr
private mul_group ::= mul_expr | div_expr | floor_div_expr | mod_expr | concat_expr
private add_group ::= plus_expr | minus_expr

/*
 * Original grammar from lua
 * simpleexp ::= NUMBER | STRING | 'nil' | 'true' | 'false' | '...' | tableconstructor | attributes 'function' funcbody | prefixexp | ifelseexp | stringinterp
 * asexp ::= simpleexp ['::' Type]
 * exp:= asexp { binop exp } | unop exp { binop exp }
 * I did it the way that I try an as_exp first and a normal one
 *  | as_expr
 *  | primary_group
 * I should have known that this is highly ineffective, because we literally parse the same thing twice.
 * Because
 * as_expr ::= (ifelse_expr | table_constructor_expr | literal_expr | closure_expr | template_string_expr | value_expr) '::' type { pin = 2 }
 * private primary_group ::= table_constructor_expr | literal_expr | closure_expr | template_string_expr | value_expr
 * It's literally the same, except for if else, because I consider it a less prioritized expressions so it's in the top separately (I'm not sure I'm correct)
 * I think the better way should be to add cast as an left rule, so it will be optional and eat the parent if needed.
 *
 * Btw, ifelseexp doesn't make sense in a simpleexp, since it's not simple. You can add a cast after it but it's attributed to the last expression not to if else statement.
 *
 */

// private primary_group ::= (table_constructor_expr | literal_expr | closure_expr | template_string_expr | value_expr) as_expr?
// Looks like this one doesn't work as I expect. I expect it to parse all the expressions and add as_expr part to the end.
// But it does
// if (!r) r = value_expr(b, l + 1);
// if (!r) r = as_expr(b, l + 1);
// So as_expr is parse only if the previous ones are not parsed
// I tried a lot of combinations. The idea is to wrap all these into a cast if it's there. But if the primary_group stays private
// it doesn't work like this and instead tries to parse cast as one more union option. (most probably it's a bug)
// If you make primary_group_expr non private (and you have to make it an expr then) then everything is good.
// I tried making as_expr both upper and left, and they work the same.
// primary_group_expr basically doesn't exist in the PSI
left as_expr ::= '::' type { pin = 1 }
// It's impossible to call a function or index a value except for ID and parenthesised expression.
// That's why the first 4 are not considered a value here. Naming sucks
primary_group_expr ::= (table_constructor_expr | literal_expr | closure_expr | template_string_expr | value_expr) as_expr?

// public rules for each expression
unary_min_expr ::= un_minus_op expression
length_expr ::= un_length_op expression
not_expr ::= un_not_op expression
div_expr ::= expression div_op expression
floor_div_expr ::= expression floor_div_op expression
mod_expr ::= expression mod_op expression
concat_expr ::= expression concat_op expression
mul_expr ::= expression mul_op expression
minus_expr ::= expression minus_op expression
plus_expr ::= expression plus_op expression

div_op ::= '/'
floor_div_op ::= '//'
mod_op ::= '%'
concat_op ::= '..'
mul_op ::= '*'
minus_op ::= '-'
plus_op ::= '+'
comparison_op ::= '<' | '<=' | '>' | '>=' | '==' | '~='
and_op ::= 'and'
or_op ::= 'or'

comparison_expr ::= expression comparison_op expression { pin = 2 }
and_expr ::= expression and_op expression
or_expr ::= expression or_op expression
exp_expr ::= expression ('^' expression) + // N-ary variant, the "(<op> expr ) +" syntax is mandatory.
paren_expr ::= '(' expression ')'

literal_expr ::= NUMBER | STRING | 'nil' | 'true' | 'false' | '...'
closure_expr ::= attributes? 'function' func_body { pin = 2 }
template_string_expr ::= TEMPLATE_STRING_SQUOTE (STRING | '{' expression '}')* TEMPLATE_STRING_EQUOTE { pin = 1 }
ifelse_expr ::= 'if' expression 'then' expression ('elseif' expression 'then' expression)* 'else' expression { pin = 1 }
table_constructor_expr ::= table_constructor

compound_op ::= '+=' | '-=' | '*=' | '/=' | '%=' | '^=' | '..=' | '//='
un_minus_op ::= '-'
un_not_op ::= 'not'
un_length_op ::= '#'

/* I see this in Haxe
    // Do NOT genericize objectLiteral by making objectLiteralElementList optional.  Doing so
    // makes blockStatement be overridden by objectLiteral in return statements.
   Does it make sense for me as well?
*/
table_constructor ::= '{' <<list_with_trailing_sep field field_sep>>? '}' { pin = 1 }
field ::= keyed_field | string_keyed_field | indexed_field { recoverWhile = field_recover }
// Added for the nice scope selection in the first place
computed_key ::= '[' expression ']' { pin = 1 }
keyed_field ::= computed_key '=' expression { pin = 1; }
string_keyed_field ::= ID '=' expression { pin = 2; }
indexed_field ::= expression
private field_recover ::= !(',' | ';' | '}' | '[')
// Why the hell they allow two separators
field_sep ::= ',' | ';'

// Types
simple_type ::=
    'nil'
    | singleton_type
    | typeof_soft_keyword '(' expression ')'
    | ID ('.' ID)? ('<' type_params? '>')?
    | type_function
    | type_table
    | '(' type ')'

singleton_type ::= STRING | 'true' | 'false'

// [06/05/2024] Why ? is used in UnionSuffix only, is it not possible to use with &?
// [04/03/2025] Because ? is a union and union and intersection cannot be mixed without parenthesis

// I intentionally diverged from the grammar here and allowed simple_type as a separate option,
// because type_union and type_intersection match empty input if does strictly as in grammar.
// Plus it's strange to have a union node when there are no union in reality, just a type.
type_union ::= (simple_type '?'?)? ('|' simple_type '?'?)+
type_intersection ::= simple_type? ('&' simple_type)+
// As always complex types go first otherwise simple_type is parsed and then complains that you wrote a bad thing.
type ::= type_union | type_intersection | simple_type '?'?

generic_type_pack_parameter ::= ID '...'
generic_type_pack_parameter_with_default ::= ID '...' '=' (type_pack | variadic_type_pack | generic_type_pack)

// Having just ID before the ... breaks everything, because T... will match just ID and go another step and then later fail, but it won't backtrack and try ...
generic_type_list ::= <<list generic_type_pack_parameter>> | ID (',' generic_type_list)?

generic_type_list_with_defaults ::=
  <<list generic_type_pack_parameter_with_default>>
 | ID '=' type (',' generic_type_list_with_defaults_only)?
 | generic_type_pack_parameters_with_default
 | ID (',' generic_type_list_with_defaults)?

private generic_type_list_with_defaults_only ::=
      <<list generic_type_pack_parameter_with_default>>
     | ID '=' type (',' generic_type_list_with_defaults_only)?

private generic_type_pack_parameters_with_default ::= generic_type_pack_parameter ((',' generic_type_pack_parameter_with_default)+ | (',' generic_type_pack_parameters_with_default)?)

// TODO: Add pins and recovery here.
type_list ::= type (',' type_list)? | '...' type
bound_type_list ::= variadic_type_pack | generic_type_pack | (ID ':')? type (',' bound_type_list)? { recoverWhile = bound_type_list_recover }
private bound_type_list_recover ::= !(')')
/* The order of types here is fragile, and I'm not 100% sure the finally correct one.
 * If you put type first it boggles the generic type packs by parsing the Type first without ...
 * If you put type last it won't parse the function, because type_pack will go first and then -> is a garbage
 * Another solution to resolve both of these problems would be to use negative lookahead and don't parse the type with ... ahead or
 * type_pack with -> ahead. But I believe it's a bit worse for performance than just the order. Let's see how far we can go.
 *
 * Overall I think that relations and possible order of real usages are to hard to explain in grammar. So most of the errors go level above, as TypeError
 */
type_params ::= (variadic_type_pack | generic_type_pack | type | type_pack) (',' type_params)?
type_pack ::= '(' type_list? ')'
generic_type_pack ::= ID '...'
variadic_type_pack ::= '...' type
return_type ::= variadic_type_pack | generic_type_pack | type | type_pack
type_computed_key ::= '[' type ']'
type_keyed_field ::= type_computed_key ':' type
type_string_keyed_field ::= ID ':' type
type_field ::= type_string_keyed_field | type_keyed_field
// First branch is array type, second branch is table and empty table
type_table ::= '{' type '}' | '{' <<list_with_trailing_sep type_field field_sep>>? '}'
// I can't pin '(' because there is '(' type ')' type as well
type_function ::= type_parameters_list? '(' bound_type_list? ')' '->' return_type { pin = 5; }

