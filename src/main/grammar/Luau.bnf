{
  parserClass="com.github.aleksandrsl.intellijluau.parser.LuauParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Luau"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.aleksandrsl.intellijluau.psi"
  psiImplPackage="com.github.aleksandrsl.intellijluau.psi.impl"
  psiImplUtilClass="com.github.aleksandrsl.intellijluau.psi.LuauPsiImplUtilKt"

  elementTypeHolderClass="com.github.aleksandrsl.intellijluau.psi.LuauTypes"
  elementTypeClass="com.github.aleksandrsl.intellijluau.psi.LuauElementType"
  tokenTypeClass="com.github.aleksandrsl.intellijluau.psi.LuauTokenType"

  tokens = [
          space = "regexp:\s+"
          AND = "and"
          BREAK = "break"
          DO = "do"
          ELSE = "else"
          ELSEIF = "elseif"
          END = "end"
          FALSE = "false"
          FOR = "for"
          FUNCTION = "function"
          IF = "if"
          IN = "in"
          LOCAL = "local"
          NIL = "nil"
          NOT = "not"
          OR = "or"
          REPEAT = "repeat"
          RETURN = "return"
          THEN = "then"
          TRUE = "true"
          UNTIL = "until"
          WHILE = "while"
          REGION = "REGION"
          ENDREGION = "ENDREGION"

          SHEBANG = "#!"
          SHEBANG_CONTENT = "SHEBANG_CONTENT"
          ELLIPSIS = "..."
          CONCAT = ".."
          EQ = "=="
          GE = ">="
          LE = "<="
          NE = "~="
          MINUS = "-"
          PLUS = "+"
          MULT = "*"
          MOD = "%"
          DIV = "/"
          ASSIGN = "="
          GT = ">"
          LT = "<"
          LPAREN = "("
          RPAREN = ")"
          LBRACK = "["
          RBRACK = "]"
          LCURLY = "{"
          RCURLY = "}"
          GETN = "#"
          COMMA = ","
          SEMI = ";"
          COLON = ":"
          DOT = "."
          EXP = "^"
          QUESTION = "?"
          DOUBLE_COLON = "::"
          DOUBLE_DIV = "//"

          PLUS_EQ = "+="
          MINUS_EQ = "-="
          MULT_EQ = "*="
          DIV_EQ = "/="
          DOUBLE_DIV_EQ = "//="
          MOD_EQ = "%="
          EXP_EQ = "^="
          CONCAT_EQ = "..="
          ARROW = "->"
          UNION = "|"
          INTERSECTION = "&"

          SHORT_COMMENT="SHORT_COMMENT"
          DOC_BLOCK_COMMENT="DOC_BLOCK_COMMENT"
          DOC_COMMENT="DOC_COMMENT"
          BLOCK_COMMENT="BLOCK_COMMENT"
          ID="regexp:[A-Za-z_][A-Za-z0-9_]*"
          NUMBER="regexp:[0-9]+"
          STRING = "regexp:\"\S*\""
    ]

    implements(".*soft_keyword") = "com.github.aleksandrsl.intellijluau.psi.LuauSoftKeyword"
}


luau_file ::= shebang_line? block
shebang_line ::= SHEBANG SHEBANG_CONTENT

block ::= (statement ';'?)* (last_statement ';'?)?
statement ::=
     assignment_statement
     | type_declaration_statement
     | function_call
     | do_statement
     | while_statement
     | repeat_statement
     | if_statement
     // Maybe not the best fix, but expressionStatement is moved below ifStatement on purpose
     // expressionStatement includes ifExpression but most of the time we want ifStatement to be matched first, e.g. to fix nested conditions
     | expression_statement
     | classic_for_statement
     | foreach_statement
     | def_statement

do_statement ::= 'do' block 'end'
while_statement ::= 'while' expression 'do' block 'end'
repeat_statement ::= 'repeat' block 'until' expression
if_statement ::= 'if' expression 'then' block ('elseif' expression 'then' block)* ('else' block)? 'end'
// TODO: Should I have a binding list here?
classic_for_statement ::= 'for' binding '=' expression ',' expression (',' expression)? 'do' block 'end'
foreach_statement ::= 'for' binding_list 'in' exp_list 'do' block 'end'
assignment_statement ::= varList '=' exp_list | local_def_statement | var compound_op expression
expression_statement ::= expression
private def_statement ::= class_method_def_statement | func_def_statement | local_func_def_statement
last_statement ::= 'return' exp_list? | 'break' | continue_soft_keyword
type_declaration_statement ::= export_soft_keyword ? type_soft_keyword ID ('<' generic_type_list_with_defaults '>')? '=' type
export_soft_keyword ::= 'export'
continue_soft_keyword ::= 'continue'
type_soft_keyword ::= 'type'
typeof_soft_keyword ::= 'typeof'

local_def_statement ::= 'local' binding_list ('=' exp_list)?
func_def_statement ::= 'function' func_name func_body
//classMethodName ::=  nameExpr (funcPrefixRef)* (('.' ID) | (':' ID))
//class_method_def_statement ::= 'function' classMethodName funcBody
local_func_def_statement ::= 'local' 'function' func_name func_body

func_name ::= ID ('.' ID)* (':' ID)?
func_body ::= ('<' generic_type_list '>')? '(' par_list? ')' (':' return_type)? block 'end'
par_list ::= binding_list (',' '...')? | '...' (':' (type | generic_type_pack))?

exp_list ::= (expression ',')* expression

// Needed for assignments with local. You shouldn't be able to use `local a.b.c = 10`
binding ::= ID (':' type)?  {
  // No idea why they use mixins or methods instead of extend, probably because they need more than one implementation
  // But usually it's not the case.
  extends="com.github.aleksandrsl.intellijluau.psi.LuauNamedElementImpl";
  implements="com.github.aleksandrsl.intellijluau.psi.LuauNamedElement"
}
binding_list ::= binding (',' binding)* // equivalent of Lua 5.1 'namelist', except with optional type annotations

varList ::= var (',' var)*
var ::= simple_var postfix_exp*
simple_var ::= var_reference | '(' expression ')'
var_reference ::= ID { methods=[getReferences] }
prefix_exp ::= (var | '(' expression ')') postfix_exp*
postfix_exp ::= func_args | ':' ID func_args | '[' expression ']' | '.' ID
function_call ::= prefix_exp postfix_exp

expression ::= simple_exp | as_exp | unary_exp | binary_exp
// See this https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities for extends example. In this case Parser switches to a different algo (Pratt) so it's ok to have left-recursion
unary_exp ::= un_op expression {extends=expression}
binary_exp ::= expression bin_op expression {extends=expression}
ifelse_exp ::= 'if' expression 'then' expression ('elseif' expression 'then' expression)* 'else' expression
as_exp ::= simple_exp '::' type {extends=expression}
template_string ::= TEMPLATE_STRING_SQUOTE (STRING | ('{' expression '}'))* TEMPLATE_STRING_EQUOTE
simple_exp ::= NUMBER | STRING | 'nil' | 'true' | 'false' | '...' | table_constructor | closure_exp | prefix_exp | ifelse_exp | template_string {extends=expression}
func_args ::=  '(' exp_list? ')' | table_constructor | STRING

closure_exp ::= 'function' func_body

table_constructor ::= '{' field_list? '}'
field_list ::= field (field_sep field)* field_sep?
field ::= '[' expression ']' '=' expression | ID '=' expression | expression
// Why the hell they allow two separators
field_sep ::= ',' | ';'

compound_op ::= '+=' | '-=' | '*=' | '/=' | '%=' | '^=' | '..=' | '//='
bin_op ::= '+' | '-' | '*' | '/' | '//' | '^' | '%' | '..' | '<' | '<=' | '>' | '>=' | '==' | '~=' | 'and' | 'or'
un_op ::= '-' | 'not' | '#'

simple_type ::=
    'nil'
    | singleton_type
    | typeof_soft_keyword '(' expression ')'
    | ID ('.' ID)? ('<' type_params? '>')?
    | table_type
    | function_type
    | '(' type ')'

singleton_type ::= STRING | 'true' | 'false'

// Why ? is used in UnionSuffix only, is it not possible to use with &? I'll move it for now.
union_suffix ::= ('|' simple_type '?'?)+
intersection_suffix ::= ('&' simple_type)+
type ::= simple_type '?'? (union_suffix | intersection_suffix)*

generic_type_pack_parameter ::= ID '...'
generic_type_list ::= ID (',' generic_type_list)? | generic_type_pack_parameter (',' generic_type_pack_parameter)*

generic_type_pack_parameter_with_default ::= ID '...' '=' (type_pack | variadic_type_pack | generic_type_pack)
generic_type_list_with_defaults ::=
    generic_type_list (',' generic_type_pack_parameter_with_default)*
    | ID (',' ID)* (',' ID '=' type)* (',' generic_type_pack_parameter_with_default)*
    | ID '=' type (',' generic_type_pack_parameter_with_default)*
    | generic_type_pack_parameter_with_default (',' generic_type_pack_parameter_with_default)*

type_list ::= type (',' type_list)? | '...' type
bound_type_list ::= (ID ':')? type (',' bound_type_list)? | '...' type
type_params ::= (type | type_pack | variadic_type_pack | generic_type_pack) (',' type_params)?
type_pack ::= '(' type_list? ')'
generic_type_pack ::= ID '...'
variadic_type_pack ::= '...' type
return_type ::= type | type_pack
table_indexer ::= '[' type ']' ':' type
table_prop ::= ID ':' type
private table_prop_or_indexer ::= table_prop | table_indexer
prop_list ::= table_prop_or_indexer (field_sep table_prop_or_indexer)* field_sep?
table_type ::= '{' type '}' | '{' prop_list? '}'
function_type ::= ('<' generic_type_list '>')? '(' bound_type_list? ')' '->' return_type
